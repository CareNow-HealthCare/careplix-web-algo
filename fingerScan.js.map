{
  "version": 3,
  "sources": ["../src/fingerScan.js"],
  "sourcesContent": ["const fingerScan = (() => {\n  let calibrationTime = 10000;\n  let scanTime = 60000;\n  let strictMode = false;\n  let isScanning = false;\n  let frameID = 0;\n  let start_time = 0;\n  let noDetectionCount = 0;\n  let wakeLock = undefined;\n  let video;\n  let canvas;\n  let ctx;\n  let raw_intensity = [];\n  let ppg_time = [];\n  let onFrameCallback = ({ timeElapsed = 0, type = \"\", percentage = 0, isFingerInView = false }) => {};\n  let onScanFinishCallback = ({ raw_intensity = [], ppg_time = [], average_fps = 0 }) => {};\n  let onErrorCallback = (err = new Error(\"Fingerscan Error.\")) => {};\n\n  const setupCamera = () =>\n    new Promise(async (resolve, reject) => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: false,\n          video: { facingMode: \"environment\", aspectRatio: 16 / 9 },\n        });\n        stream\n          .getVideoTracks()?.[0]\n          ?.applyConstraints?.({ advanced: [{ torch: true }] })\n          .catch((err) => console.error(new Error(\"Flash could not be acquired.\", { cause: err })));\n        video.srcObject = stream;\n        video.onloadedmetadata = () => {\n          resolve();\n        };\n      } catch (err) {\n        reject(new Error(\"We are not able to access the Camera. Please try again.\", { cause: err }));\n      }\n    });\n\n  const stopScan = (noCallback = false) => {\n    cancelAnimationFrame(frameID);\n    video?.srcObject?.getTracks?.()?.forEach?.((track) => {\n      track?.stop?.();\n    });\n    isScanning = false;\n    window.onblur = undefined;\n    wakeLock\n      ?.release()\n      .then(() => console.log(\"WakeLock Released.\"))\n      .catch((err) => {\n        console.log(\"WakeLock Error.\");\n        console.error(err);\n      });\n    if (!noCallback)\n      onScanFinishCallback({\n        raw_intensity,\n        ppg_time,\n        average_fps: Math.round((raw_intensity.length * 1000) / scanTime),\n      });\n  };\n\n  const calcQuality = (rgb = { r: 0, g: 0, b: 0 }) => {\n    let confidence = undefined;\n    if (rgb.r < (strictMode ? 25 : 5)) confidence = 0;\n    else {\n      const nonRed = rgb.g + rgb.b;\n      const min = strictMode ? 35 : 60;\n      const max = strictMode ? 125 : 150;\n      if (nonRed <= min) confidence = 1;\n      else if (nonRed >= max) confidence = 0;\n      else confidence = (max - nonRed) / min;\n    }\n    return confidence;\n  };\n\n  const calcRGB_fromImageData = (imgData) => {\n    let count = 0,\n      sumRGB = { r: 0, g: 0, b: 0 };\n    for (let i = 0; i < imgData.data.length; i += 4)\n      if (imgData.data[i + 3] > 0) {\n        count++;\n        sumRGB.r += imgData.data[i];\n        sumRGB.g += imgData.data[i + 1];\n        sumRGB.b += imgData.data[i + 2];\n      }\n    return { r: sumRGB.r / count, g: sumRGB.g / count, b: sumRGB.b / count };\n  };\n\n  const drawCanvas = () => {\n    const imageWidth = video.videoWidth;\n    const imageHeight = video.videoHeight;\n    ctx.save();\n    ctx.clearRect(0, 0, imageWidth, imageHeight);\n    ctx.drawImage(video, 0, 0, imageWidth, imageHeight);\n    const avgRGB = calcRGB_fromImageData(ctx.getImageData(imageWidth / 5, imageHeight / 5, imageWidth * 0.6, imageHeight * 0.6));\n    ctx.restore();\n    return avgRGB;\n  };\n\n  const scan = async (loop_start_time) => {\n    const timeElapsed = loop_start_time - start_time;\n    try {\n      if (timeElapsed <= calibrationTime) {\n        const intensity = drawCanvas();\n        const quality = calcQuality(intensity);\n        onFrameCallback({\n          timeElapsed,\n          type: \"calibration\",\n          percentage: Math.round((timeElapsed / calibrationTime) * 100),\n          isFingerInView: quality > 0.6,\n        });\n        frameID = requestAnimationFrame(scan);\n      } else if (timeElapsed <= calibrationTime + scanTime) {\n        const intensity = drawCanvas();\n        const quality = calcQuality(intensity);\n        if (quality > 0.6) noDetectionCount = 0;\n        else {\n          if (strictMode) noDetectionCount = 101;\n          else noDetectionCount++;\n        }\n        if (noDetectionCount > 100) {\n          stopScan(true);\n          onErrorCallback(new Error(\"Finger movement detected during the scan.\"));\n          return;\n        }\n        raw_intensity.push(intensity);\n        ppg_time.push(performance.now() - start_time);\n        onFrameCallback({\n          timeElapsed,\n          type: \"scan\",\n          percentage: Math.round(((timeElapsed - calibrationTime) / scanTime) * 100),\n          isFingerInView: quality > 0.6,\n        });\n        frameID = requestAnimationFrame(scan);\n      } else stopScan();\n    } catch (err) {\n      stopScan(true);\n      onErrorCallback(new Error(\"Sorry we're unable to compute the signal. Please try again.\", { cause: err }));\n    }\n  };\n\n  const startScan = async ({\n    calibrationTime_inSec = 10,\n    scanTime_inSec = 60,\n    strict_mode = false,\n    videoElement,\n    canvasElement,\n  }) => {\n    raw_intensity = [];\n    ppg_time = [];\n    isScanning = false;\n    noDetectionCount = 0;\n\n    try {\n      if (typeof calibrationTime_inSec !== \"number\" || calibrationTime_inSec < 3 || calibrationTime_inSec > 20)\n        throw new Error(\"Calibration duration can be between 3-20 seconds.\");\n      if (typeof scanTime_inSec !== \"number\" || scanTime_inSec < 10 || scanTime_inSec > 120 || scanTime_inSec % 5 !== 0)\n        throw new Error(\"Scan duration can be between 10-120 seconds (multiple of 5).\");\n      if (calibrationTime_inSec > scanTime_inSec) throw new Error(\"Scan duration cannot be smaller than Calibration duration.\");\n      calibrationTime = calibrationTime_inSec * 1000;\n      scanTime = scanTime_inSec * 1000;\n      if (typeof strict_mode !== \"boolean\") {\n        console.error(\"Provided Strict Mode value is Invalid!\\nSwitching to default...\");\n        strictMode = false;\n      } else strictMode = strict_mode;\n\n      navigator.wakeLock\n        ?.request(\"screen\")\n        .then((wakeLockSentinel) => {\n          wakeLock = wakeLockSentinel;\n          console.log(\"WakeLock Active.\");\n        })\n        .catch((err) => {\n          console.log(\"WakeLock Error.\");\n          console.error(err);\n        });\n\n      video = typeof videoElement === \"undefined\" ? document.getElementById(\"videoInput\") : videoElement;\n      if (video) {\n        await setupCamera();\n        await video.play?.();\n      } else throw new Error(\"Cannot get the video element.\");\n\n      canvas = typeof canvasElement === \"undefined\" ? document.getElementById(\"canvasOutput\") : canvasElement;\n      if (canvas) {\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        ctx = canvas.getContext(\"2d\");\n      } else throw new Error(\"Cannot get the canvas element.\");\n\n      start_time = performance.now();\n      frameID = requestAnimationFrame(scan);\n      isScanning = true;\n      window.onblur = () => {\n        stopScan(true);\n        onErrorCallback(\n          new Error(\"App functionality disabled in the Background. Keep it in the Foreground for proper operation.\")\n        );\n      };\n    } catch (err) {\n      stopScan(true);\n      onErrorCallback(err);\n      throw new Error(\"Fingerscan Initialization Error.\", { cause: err });\n    }\n  };\n\n  return {\n    startScan,\n    stopScan,\n    onFrame: (callback = ({ timeElapsed = 0, type = \"\", percentage = 0, isFingerInView = false }) => {}) => {\n      if (typeof callback === \"function\") onFrameCallback = callback;\n    },\n    onScanFinish: (callback = ({ raw_intensity = [], ppg_time = [], average_fps = 0 }) => {}) => {\n      if (typeof callback === \"function\") onScanFinishCallback = callback;\n    },\n    onError: (callback = (err = new Error(\"Fingerscan Error.\")) => {}) => {\n      if (typeof callback === \"function\") onErrorCallback = callback;\n    },\n    get isInitializing() {\n      return () => !Boolean(isScanning);\n    },\n    get isScanning() {\n      return () => Boolean(isScanning);\n    },\n  };\n})();\n\nexport default fingerScan;\n"],
  "mappings": "AAAA,IAAMA,GAAc,IAAM,CACxB,IAAIC,EAAkB,IAClBC,EAAW,IACXC,EAAa,GACbC,EAAa,GACbC,EAAU,EACVC,EAAa,EACbC,EAAmB,EACnBC,EACAC,EACAC,EACAC,EACAC,EAAgB,CAAC,EACjBC,EAAW,CAAC,EACZC,EAAkB,CAAC,CAAE,YAAAC,EAAc,EAAG,KAAAC,EAAO,GAAI,WAAAC,EAAa,EAAG,eAAAC,EAAiB,EAAM,IAAM,CAAC,EAC/FC,EAAuB,CAAC,CAAE,cAAAP,EAAgB,CAAC,EAAG,SAAAC,EAAW,CAAC,EAAG,YAAAO,EAAc,CAAE,IAAM,CAAC,EACpFC,EAAkB,CAACC,EAAM,IAAI,MAAM,mBAAmB,IAAM,CAAC,EAE3DC,EAAc,IAClB,IAAI,QAAQ,MAAOC,EAASC,IAAW,CAnB3C,IAAAC,EAAAC,EAAAC,EAoBM,GAAI,CACF,IAAMC,EAAS,MAAM,UAAU,aAAa,aAAa,CACvD,MAAO,GACP,MAAO,CAAE,WAAY,cAAe,YAAa,kBAAO,CAC1D,CAAC,GACDD,GAAAD,GAAAD,EAAAG,EACG,eAAe,IADlB,YAAAH,EACsB,KADtB,YAAAC,EAEI,mBAFJ,MAAAC,EAAA,KAAAD,EAEuB,CAAE,SAAU,CAAC,CAAE,MAAO,EAAK,CAAC,CAAE,GAClD,MAAOL,GAAQ,QAAQ,MAAM,IAAI,MAAM,+BAAgC,CAAE,MAAOA,CAAI,CAAC,CAAC,GACzFb,EAAM,UAAYoB,EAClBpB,EAAM,iBAAmB,IAAM,CAC7Be,EAAQ,CACV,CACF,OAASF,EAAK,CACZG,EAAO,IAAI,MAAM,0DAA2D,CAAE,MAAOH,CAAI,CAAC,CAAC,CAC7F,CACF,CAAC,EAEGQ,EAAW,CAACC,EAAa,KAAU,CAtC3C,IAAAL,EAAAC,EAAAC,EAAAI,EAuCI,qBAAqB3B,CAAO,GAC5B2B,GAAAJ,GAAAD,GAAAD,EAAAjB,GAAA,YAAAA,EAAO,YAAP,YAAAiB,EAAkB,YAAlB,YAAAC,EAAA,KAAAD,KAAA,YAAAE,EAAiC,UAAjC,MAAAI,EAAA,KAAAJ,EAA4CK,GAAU,CAxC1D,IAAAP,GAyCMA,EAAAO,GAAA,YAAAA,EAAO,OAAP,MAAAP,EAAA,KAAAO,EACF,GACA7B,EAAa,GACb,OAAO,OAAS,OAChBI,GAAA,MAAAA,EACI,UACD,KAAK,IAAM,QAAQ,IAAI,oBAAoB,GAC3C,MAAOc,GAAQ,CACd,QAAQ,IAAI,iBAAiB,EAC7B,QAAQ,MAAMA,CAAG,CACnB,GACGS,GACHZ,EAAqB,CACnB,cAAAP,EACA,SAAAC,EACA,YAAa,KAAK,MAAOD,EAAc,OAAS,IAAQV,CAAQ,CAClE,CAAC,CACL,EAEMgC,EAAc,CAACC,EAAM,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,IAAM,CAClD,IAAIC,EACJ,GAAID,EAAI,GAAKhC,EAAa,GAAK,GAAIiC,EAAa,MAC3C,CACH,IAAMC,EAASF,EAAI,EAAIA,EAAI,EACrBG,EAAMnC,EAAa,GAAK,GACxBoC,EAAMpC,EAAa,IAAM,IAC3BkC,GAAUC,EAAKF,EAAa,EACvBC,GAAUE,EAAKH,EAAa,EAChCA,GAAcG,EAAMF,GAAUC,CACrC,CACA,OAAOF,CACT,EAEMI,EAAyBC,GAAY,CACzC,IAAIC,EAAQ,EACVC,EAAS,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAE,EAC9B,QAASC,EAAI,EAAGA,EAAIH,EAAQ,KAAK,OAAQG,GAAK,EACxCH,EAAQ,KAAKG,EAAI,CAAC,EAAI,IACxBF,IACAC,EAAO,GAAKF,EAAQ,KAAKG,CAAC,EAC1BD,EAAO,GAAKF,EAAQ,KAAKG,EAAI,CAAC,EAC9BD,EAAO,GAAKF,EAAQ,KAAKG,EAAI,CAAC,GAElC,MAAO,CAAE,EAAGD,EAAO,EAAID,EAAO,EAAGC,EAAO,EAAID,EAAO,EAAGC,EAAO,EAAID,CAAM,CACzE,EAEMG,EAAa,IAAM,CACvB,IAAMC,EAAarC,EAAM,WACnBsC,EAActC,EAAM,YAC1BE,EAAI,KAAK,EACTA,EAAI,UAAU,EAAG,EAAGmC,EAAYC,CAAW,EAC3CpC,EAAI,UAAUF,EAAO,EAAG,EAAGqC,EAAYC,CAAW,EAClD,IAAMC,EAASR,EAAsB7B,EAAI,aAAamC,EAAa,EAAGC,EAAc,EAAGD,EAAa,GAAKC,EAAc,EAAG,CAAC,EAC3H,OAAApC,EAAI,QAAQ,EACLqC,CACT,EAEMC,EAAO,MAAOC,GAAoB,CACtC,IAAMnC,EAAcmC,EAAkB5C,EACtC,GAAI,CACF,GAAIS,GAAed,EAAiB,CAClC,IAAMkD,EAAYN,EAAW,EACvBO,EAAUlB,EAAYiB,CAAS,EACrCrC,EAAgB,CACd,YAAAC,EACA,KAAM,cACN,WAAY,KAAK,MAAOA,EAAcd,EAAmB,GAAG,EAC5D,eAAgBmD,EAAU,EAC5B,CAAC,EACD/C,EAAU,sBAAsB4C,CAAI,CACtC,SAAWlC,GAAed,EAAkBC,EAAU,CACpD,IAAMiD,EAAYN,EAAW,EACvBO,EAAUlB,EAAYiB,CAAS,EAMrC,GALIC,EAAU,GAAK7C,EAAmB,EAEhCJ,EAAYI,EAAmB,IAC9BA,IAEHA,EAAmB,IAAK,CAC1BuB,EAAS,EAAI,EACbT,EAAgB,IAAI,MAAM,2CAA2C,CAAC,EACtE,MACF,CACAT,EAAc,KAAKuC,CAAS,EAC5BtC,EAAS,KAAK,YAAY,IAAI,EAAIP,CAAU,EAC5CQ,EAAgB,CACd,YAAAC,EACA,KAAM,OACN,WAAY,KAAK,OAAQA,EAAcd,GAAmBC,EAAY,GAAG,EACzE,eAAgBkD,EAAU,EAC5B,CAAC,EACD/C,EAAU,sBAAsB4C,CAAI,CACtC,MAAOnB,EAAS,CAClB,OAASR,EAAK,CACZQ,EAAS,EAAI,EACbT,EAAgB,IAAI,MAAM,8DAA+D,CAAE,MAAOC,CAAI,CAAC,CAAC,CAC1G,CACF,EAmEA,MAAO,CACL,UAlEgB,MAAO,CACvB,sBAAA+B,EAAwB,GACxB,eAAAC,EAAiB,GACjB,YAAAC,EAAc,GACd,aAAAC,EACA,cAAAC,CACF,IAAM,CAlJR,IAAA/B,EAAAC,EAmJIf,EAAgB,CAAC,EACjBC,EAAW,CAAC,EACZT,EAAa,GACbG,EAAmB,EAEnB,GAAI,CACF,GAAI,OAAO8C,GAA0B,UAAYA,EAAwB,GAAKA,EAAwB,GACpG,MAAM,IAAI,MAAM,mDAAmD,EACrE,GAAI,OAAOC,GAAmB,UAAYA,EAAiB,IAAMA,EAAiB,KAAOA,EAAiB,IAAM,EAC9G,MAAM,IAAI,MAAM,8DAA8D,EAChF,GAAID,EAAwBC,EAAgB,MAAM,IAAI,MAAM,4DAA4D,EAoBxH,GAnBArD,EAAkBoD,EAAwB,IAC1CnD,EAAWoD,EAAiB,IACxB,OAAOC,GAAgB,WACzB,QAAQ,MAAM,iEAAiE,EAC/EpD,EAAa,IACRA,EAAaoD,GAEpB7B,EAAA,UAAU,WAAV,MAAAA,EACI,QAAQ,UACT,KAAMgC,GAAqB,CAC1BlD,EAAWkD,EACX,QAAQ,IAAI,kBAAkB,CAChC,GACC,MAAOpC,GAAQ,CACd,QAAQ,IAAI,iBAAiB,EAC7B,QAAQ,MAAMA,CAAG,CACnB,GAEFb,EAAQ,OAAO+C,EAAiB,IAAc,SAAS,eAAe,YAAY,EAAIA,EAClF/C,EACF,MAAMc,EAAY,EAClB,OAAMI,EAAAlB,EAAM,OAAN,YAAAkB,EAAA,KAAAlB,QACD,OAAM,IAAI,MAAM,+BAA+B,EAGtD,GADAC,EAAS,OAAO+C,EAAkB,IAAc,SAAS,eAAe,cAAc,EAAIA,EACtF/C,EACFA,EAAO,MAAQD,EAAM,WACrBC,EAAO,OAASD,EAAM,YACtBE,EAAMD,EAAO,WAAW,IAAI,MACvB,OAAM,IAAI,MAAM,gCAAgC,EAEvDJ,EAAa,YAAY,IAAI,EAC7BD,EAAU,sBAAsB4C,CAAI,EACpC7C,EAAa,GACb,OAAO,OAAS,IAAM,CACpB0B,EAAS,EAAI,EACbT,EACE,IAAI,MAAM,+FAA+F,CAC3G,CACF,CACF,OAASC,EAAK,CACZ,MAAAQ,EAAS,EAAI,EACbT,EAAgBC,CAAG,EACb,IAAI,MAAM,mCAAoC,CAAE,MAAOA,CAAI,CAAC,CACpE,CACF,EAIE,SAAAQ,EACA,QAAS,CAAC6B,EAAW,CAAC,CAAE,YAAA5C,EAAc,EAAG,KAAAC,EAAO,GAAI,WAAAC,EAAa,EAAG,eAAAC,EAAiB,EAAM,IAAM,CAAC,IAAM,CAClG,OAAOyC,GAAa,aAAY7C,EAAkB6C,EACxD,EACA,aAAc,CAACA,EAAW,CAAC,CAAE,cAAA/C,EAAgB,CAAC,EAAG,SAAAC,EAAW,CAAC,EAAG,YAAAO,EAAc,CAAE,IAAM,CAAC,IAAM,CACvF,OAAOuC,GAAa,aAAYxC,EAAuBwC,EAC7D,EACA,QAAS,CAACA,EAAW,CAACrC,EAAM,IAAI,MAAM,mBAAmB,IAAM,CAAC,IAAM,CAChE,OAAOqC,GAAa,aAAYtC,EAAkBsC,EACxD,EACA,IAAI,gBAAiB,CACnB,MAAO,IAAM,CAASvD,CACxB,EACA,IAAI,YAAa,CACf,MAAO,IAAM,EAAQA,CACvB,CACF,CACF,GAAG,EAEIwD,EAAQ5D",
  "names": ["fingerScan", "calibrationTime", "scanTime", "strictMode", "isScanning", "frameID", "start_time", "noDetectionCount", "wakeLock", "video", "canvas", "ctx", "raw_intensity", "ppg_time", "onFrameCallback", "timeElapsed", "type", "percentage", "isFingerInView", "onScanFinishCallback", "average_fps", "onErrorCallback", "err", "setupCamera", "resolve", "reject", "_a", "_b", "_c", "stream", "stopScan", "noCallback", "_d", "track", "calcQuality", "rgb", "confidence", "nonRed", "min", "max", "calcRGB_fromImageData", "imgData", "count", "sumRGB", "i", "drawCanvas", "imageWidth", "imageHeight", "avgRGB", "scan", "loop_start_time", "intensity", "quality", "calibrationTime_inSec", "scanTime_inSec", "strict_mode", "videoElement", "canvasElement", "wakeLockSentinel", "callback", "fingerScan_default"]
}
